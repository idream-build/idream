module Idream.Command.Compile
  ( compile
  ) where

import Control.Monad (unless, when)
import Control.Monad.IO.Class (liftIO)
import Data.Foldable (for_)
import Data.List (intercalate, stripPrefix, groupBy)
import qualified Data.Map as Map
import Data.Maybe (fromMaybe)
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Text (Text)
import qualified Data.Text as T
import Idream.App (AppM)
import Idream.Command.Common (PackageGroup, fullPkgDepsForGroup, pkgDepsForGroup, pkgGroupToText, withResolvedProject, readPkgSetFile, mkDepInfoMap)
import Idream.Deps (linearizeDeps, lookupDeps, closureDeps)
import Idream.Effects.FileSystem (fsCopyFile, fsCreateDir, fsFindFiles, fsMakeAbsolute, fsRemovePath, fsWriteFile, fsDoesDirectoryExist)
import Idream.Effects.Process (Spec (..), procInvokeEnsure_, procDebug_)
import Idream.FileLogic (pkgSetFileName, buildDir, workDir, outputDir, installDir)
import Idream.FilePaths (Directory)
import Idream.Types.Common (PackageName (..), ProjectName (..), PackageType (..))
import Idream.Types.Internal (ResolvedProject (..), DepInfoMap (..), DepInfo (..), IdreamDepInfo (..),IpkgDepInfo (IpkgDepInfo), depInfoDepends)
import LittleLogger (logInfo)
import System.FilePath ((</>), makeRelative, isExtensionOf, (-<.>), dropExtension)

compile :: Directory -> PackageGroup -> AppM ()
compile projDir group = do
  withResolvedProject "compile" projDir $ \rp -> do
    logInfo ("Compiling project " <> unProjName (rpName rp) <> " with " <> pkgGroupToText group <> ".")
    ps <- readPkgSetFile (projDir </> pkgSetFileName)
    dim <- mkDepInfoMap rp ps
    liftIO (print dim)
    let filtDeps = fullPkgDepsForGroup rp group dim
        linPkgs = linearizeDeps filtDeps
        transDeps = closureDeps filtDeps
    liftIO (print linPkgs)
    for_ linPkgs $ \pn -> do
      let di = unDepInfoMap dim Map.! pn
          tdepends = Set.toList (lookupDeps pn transDeps)
      compilePkg projDir di pn tdepends

compilePkg :: Directory -> DepInfo -> PackageName -> [PackageName] -> AppM ()
compilePkg projDir di pn tdepends = do
  logInfo ("Compiling " <> unPkgName pn)
  install <- case di of
    DepInfoBuiltin _ -> pure False
    DepInfoIdream idi -> do
      modules <- findIpkgModules projDir idi
      liftIO (print modules)
      let path = idreamDepPath idi
          pkgFile = T.unpack (unPkgName pn) -<.> "ipkg"
          pkgContents = mkIpkgContents pn idi modules
          rootedPkgFile = projDir </> path </> pkgFile
      liftIO (print pkgContents)
      fsWriteFile rootedPkgFile pkgContents
      runIdris projDir pn path pkgFile tdepends
      pure True
    DepInfoIpkg (IpkgDepInfo path pkgFile _) -> do
      runIdris projDir pn path pkgFile tdepends
      pure True
  -- Copy TTC files to install
  when install (installFiles projDir pn)

newtype ModuleName = ModuleName
  { unModuleName :: [String]
  } deriving (Eq, Show)

moduleNameText :: ModuleName -> Text
moduleNameText = T.intercalate "." . fmap T.pack . unModuleName

findExtRel :: String -> Directory -> AppM [FilePath]
findExtRel ext dir = fmap (fmap (makeRelative dir)) (fsFindFiles (isExtensionOf ext) (Just dir))

-- | Extracts the filename for use in ipkg file.
--   e.g. LightYear/Position.idr -> LightYear.Position
extractModuleName :: FilePath -> ModuleName
extractModuleName = ModuleName . splitParts . trimPrefix . dropExtension where
  splitParts = groupBy (\_ b -> b /= '/')
  replaceSlash c = c
  trimPrefix s = fromMaybe s (stripPrefix "./" s)

findIpkgModules :: Directory -> IdreamDepInfo -> AppM [ModuleName]
findIpkgModules projDir (IdreamDepInfo _ path _ msourcedir _) = do
  let pkgPath = projDir </> path
      srcPath = maybe pkgPath (pkgPath </>) msourcedir
  idrFiles <- findExtRel "idr" srcPath
  pure (fmap extractModuleName idrFiles)

-- TODO(ejconlon) Split module and dep lists with newlines for better diffs
mkIpkgContents :: PackageName -> IdreamDepInfo -> [ModuleName] -> Text
mkIpkgContents pn (IdreamDepInfo _ path ty msourcedir depends) modules =
  let isExe = ty /= PkgTypeLibrary
      modsList = T.intercalate ", " (fmap moduleNameText modules)
      depsList = T.intercalate ", " (fmap unPkgName depends)
  in T.unlines $ filter (not . T.null)
    [ "-- AUTOGENERATED BY idream. DO NOT EDIT."
    , "package " <> unPkgName pn
    , maybe "" (\s -> "sourcedir = " <> T.pack s) msourcedir
    , if isExe then "main = Main" else ""
    , if isExe then "executable = " <> unPkgName pn else ""
    , if null modules then "" else "modules = " <> modsList
    , if null depends then "" else "depends = " <> depsList
    ]

runIdris :: Directory -> PackageName -> Directory -> FilePath -> [PackageName] -> AppM ()
runIdris projDir pn path pkgFile tdepends = do
  absWorkDir <- fsMakeAbsolute (projDir </> workDir)
  let absBuildDir = absWorkDir </> "build"
      absOutputDir = absWorkDir </> "output"
      absInstallDir = absWorkDir </> "install"
      depNames = fmap (T.unpack . unPkgName) tdepends
      idpath = intercalate ":" (fmap (absInstallDir </>) depNames)
      env = [("IDRIS2_PATH", idpath)]
      pkgDirPart = T.unpack (unPkgName pn)
      absPkgBuildDir = absBuildDir </> pkgDirPart
      absPkgOutputDir = absOutputDir </> pkgDirPart
      args = [ "--build", pkgFile
             , "--build-dir", absPkgBuildDir
             , "--output-dir", absPkgOutputDir
             , "--verbose"
             ]
      spec = Spec "idris2" args (Just (projDir </> path)) env
  -- procInvokeEnsure_ spec
  procDebug_ spec

installFiles :: Directory -> PackageName -> AppM ()
installFiles projDir pn = do
  let pkgDirPart = T.unpack (unPkgName pn)
      pkgBuildDir = projDir </> buildDir </> pkgDirPart
      pkgTtcDir = pkgBuildDir </> "ttc"
      pkgInstallDir = projDir </> installDir </> pkgDirPart
  fsRemovePath pkgInstallDir
  ttcDirExists <- fsDoesDirectoryExist pkgTtcDir
  when ttcDirExists $ do
    ttcs <- findExtRel "ttc" pkgTtcDir
    unless (null ttcs) $ do
      fsCreateDir pkgInstallDir
      for_ ttcs (\ttc -> fsCopyFile (pkgTtcDir </> ttc) (pkgInstallDir </> ttc))
