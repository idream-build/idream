module Idream.Command.Compile
  ( compileImpl
  , MissingPackageInResolvedErr (..)
  ) where

import Data.List (groupBy, stripPrefix)
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Data.Text as T
import Idream.Command.Common (PackageGroup, findExtRel, fullPkgDepsForGroup, mkDepInfoMap, pkgGroupToText,
                              readDepInfoMap, readPkgSetFile, readResolvedProject)
import Idream.Deps (closureDeps, linearizeDeps, lookupDeps)
import Idream.Effects.FileSystem (fsCopyFile, fsCreateDir, fsDoesDirectoryExist, fsFindFiles, fsMakeAbsolute,
                                  fsRemovePath, fsWriteFile)
import Idream.Effects.Process (Spec (..), procDebug_, procInvokeEnsure_)
import Idream.FileLogic (buildDir, buildDirName, installDir, installDirName, outputDir, outputDirName, pkgSetFileName,
                         workDir)
import Idream.Prelude
import Idream.Types.Common (Codegen, PackageName, PackageType (..), ProjectName)
import Idream.Types.Internal (DepInfo (..), DepInfoMap, IdreamDepInfo (..), IpkgDepInfo (..), ResolvedProject (..),
                              depInfoDepends)
import System.FilePath (dropExtension)

newtype MissingPackageInResolvedErr = MissingPackageInResolvedErr PackageName
  deriving (Eq, Show)

instance Exception MissingPackageInResolvedErr where
  displayException (MissingPackageInResolvedErr pn) =
    "Missing packaged in resolved set: " <> toString pn

compileImpl :: Directory -> PackageGroup -> AppM ()
compileImpl projDir group = do
  rp <- readResolvedProject projDir
  logInfo ("Compiling project " <> toText (rpName rp) <> " with " <> pkgGroupToText group)
  dim <- readDepInfoMap projDir rp
  let filtDeps = fullPkgDepsForGroup rp group dim
      linPkgs = linearizeDeps filtDeps
      transDeps = closureDeps filtDeps
  for_ linPkgs $ \pn -> do
    case Map.lookup pn dim of
      Nothing -> throwIO (MissingPackageInResolvedErr pn)
      Just di -> do
        let codegen = rpCodegen rp
            tdepends = Set.toList (lookupDeps pn transDeps)
        compilePkg projDir codegen di pn tdepends
  logInfo "Finished compiling"

compilePkg :: Directory -> Codegen -> DepInfo -> PackageName -> [PackageName] -> AppM ()
compilePkg projDir codegen di pn tdepends = do
  logInfo ("Compiling " <> toText pn)
  install <- case di of
    DepInfoBuiltin _ -> pure False
    DepInfoIdream idi -> do
      modules <- findIpkgModules projDir idi
      let path = idreamDepPath idi
          pkgFile = toString pn -<.> "ipkg"
          pkgContents = mkIpkgContents pn idi modules
          rootedPkgFile = projDir </> path </> pkgFile
      fsWriteFile rootedPkgFile pkgContents
      idrisBuild projDir codegen pn path pkgFile tdepends
      pure True
    DepInfoIpkg (IpkgDepInfo path pkgFile _) -> do
      idrisBuild projDir codegen pn path pkgFile tdepends
      pure True
  -- Copy TTC files to install
  when install (installFiles projDir pn)

newtype ModuleName = ModuleName
  { unModuleName :: [Text]
  } deriving (Eq, Show)

instance ToText ModuleName where
  toText = T.intercalate "." . unModuleName

-- | Extracts the filename for use in ipkg file.
--   e.g. LightYear/Position.idr -> LightYear.Position
extractModuleName :: FilePath -> ModuleName
extractModuleName = ModuleName . fmap toText . splitParts . trimPrefix . dropExtension where
  splitParts = groupBy (\_ b -> b /= '/')
  replaceSlash c = c
  trimPrefix s = fromMaybe s (stripPrefix "./" s)

findIpkgModules :: Directory -> IdreamDepInfo -> AppM [ModuleName]
findIpkgModules projDir (IdreamDepInfo _ path _ msourcedir _) = do
  let pkgPath = projDir </> path
      srcPath = maybe pkgPath (pkgPath </>) msourcedir
  idrFiles <- findExtRel "idr" srcPath
  pure (fmap extractModuleName idrFiles)

-- TODO(ejconlon) Split module and dep lists with newlines for better diffs
mkIpkgContents :: PackageName -> IdreamDepInfo -> [ModuleName] -> Text
mkIpkgContents pn (IdreamDepInfo _ path ty msourcedir depends) modules =
  let isExe = ty /= PkgTypeLibrary
      modsList = T.intercalate ", " (fmap toText modules)
      depsList = T.intercalate ", " (fmap toText depends)
  in T.unlines $ filter (not . T.null)
    [ "-- AUTOGENERATED BY idream. DO NOT EDIT."
    , "package " <> toText pn
    , maybe "" (\s -> "sourcedir = " <> toText s) msourcedir
    , if isExe then "main = Main" else ""
    , if isExe then "executable = " <> toText pn else ""
    , if null modules then "" else "modules = " <> modsList
    , if null depends then "" else "depends = " <> depsList
    ]

idrisBuild :: Directory -> Codegen -> PackageName -> Directory -> FilePath -> [PackageName] -> AppM ()
idrisBuild projDir codegen pn path pkgFile tdepends = do
  absWorkDir <- fsMakeAbsolute (projDir </> workDir)
  let absBuildDir = absWorkDir </> buildDirName
      absOutputDir = absWorkDir </> outputDirName
      absInstallDir = absWorkDir </> installDirName
      depNames = fmap toString tdepends
      idpath = intercalate ":" (fmap (absInstallDir </>) depNames)
      env = [("IDRIS2_PATH", idpath)]
      pkgDirPart = toString pn
      absPkgBuildDir = absBuildDir </> pkgDirPart
      absPkgOutputDir = absOutputDir </> pkgDirPart
      args = [ "--build", pkgFile
             , "--build-dir", absPkgBuildDir
             , "--output-dir", absPkgOutputDir
             , "--codegen", toString codegen
             , "--verbose"
             ]
      spec = Spec "idris2" args (Just (projDir </> path)) env
  procInvokeEnsure_ spec

installFiles :: Directory -> PackageName -> AppM ()
installFiles projDir pn = do
  logInfo ("Copying build files for " <> toText pn)
  let pkgDirPart = toString pn
      pkgBuildDir = projDir </> buildDir </> pkgDirPart
      pkgTtcDir = pkgBuildDir </> "ttc"
      pkgInstallDir = projDir </> installDir </> pkgDirPart
  fsRemovePath pkgInstallDir
  ttcDirExists <- fsDoesDirectoryExist pkgTtcDir
  when ttcDirExists $ do
    ttcs <- findExtRel "ttc" pkgTtcDir
    unless (null ttcs) $ do
      fsCreateDir pkgInstallDir
      for_ ttcs (\ttc -> fsCopyFile (pkgTtcDir </> ttc) (pkgInstallDir </> ttc))
