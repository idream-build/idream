module Idream.Command.Compile
  ( compileImpl
  ) where

import Control.Monad.State (execState, modify)
import qualified Data.Set as Set
import Idream.Command.Common (PackageGroup, findExtRel, fullPkgDepsForGroup, getDepInfoMap, pkgGroupToText,
                              readDepInfoMap, readResolvedProject)
import Idream.Deps (closureDeps, linearizeDeps, lookupDeps)
import Idream.Effects.FileSystem (fsCopyDir, fsCreateDir, fsDoesDirectoryExist, fsMakeAbsolute, fsRemovePath,
                                  fsWriteFile)
import Idream.Effects.Process (Spec (..), procInvokeEnsure_)
import Idream.FileLogic (buildDir, buildDirName, installDir, installDirName, outputDirName, workDir)
import Idream.Prelude
import Idream.Types.Common (Codegen, PackageName, PackageType (..))
import Idream.Types.Internal (DepInfo (..), IdreamDepInfo (..), IpkgDepInfo (..), ResolvedProject (..))
import Idream.Types.Ipkg (ModuleName (..), PackageDesc (..), extractModuleName, minPackageDesc, unrestrictedPD)

compileImpl :: Directory -> PackageGroup -> AppM ()
compileImpl projDir group = do
  rp <- readResolvedProject projDir
  logInfo ("Compiling project " <> toText (rpName rp) <> " with " <> pkgGroupToText group)
  dim <- readDepInfoMap projDir rp
  let filtDeps = fullPkgDepsForGroup rp group dim
      linPkgs = linearizeDeps filtDeps
      transDeps = closureDeps filtDeps
  for_ linPkgs $ \pn -> do
    di <- getDepInfoMap pn dim
    let codegen = rpCodegen rp
        tdepends = Set.toList (lookupDeps pn transDeps)
    compilePkg projDir codegen di pn tdepends
  logInfo "Finished compiling"

compilePkg :: Directory -> Codegen -> DepInfo -> PackageName -> [PackageName] -> AppM ()
compilePkg projDir codegen di pn tdepends = do
  logInfo ("Compiling " <> toText pn)
  install <- case di of
    DepInfoBuiltin _ -> pure False
    DepInfoIdream idi -> do
      modules <- findIpkgModules projDir idi
      let path = iddPath idi
          pkgFile = toString pn -<.> "ipkg"
          pkgContents = mkIpkgContents pn idi modules
          rootedPkgFile = projDir </> path </> pkgFile
      fsWriteFile rootedPkgFile pkgContents
      idrisBuild projDir codegen pn path pkgFile tdepends
      pure True
    DepInfoIpkg (IpkgDepInfo path pkgFile _) -> do
      idrisBuild projDir codegen pn path pkgFile tdepends
      pure True
  -- Copy TTC files to install
  when install (installFiles projDir pn)

findIpkgModules :: Directory -> IdreamDepInfo -> AppM [ModuleName]
findIpkgModules projDir (IdreamDepInfo _ _ path _ msourcedir _) = do
  let pkgPath = projDir </> path
      srcPath = maybe pkgPath (pkgPath </>) msourcedir
  idrFiles <- findExtRel "idr" srcPath
  pure (fmap extractModuleName idrFiles)

mkIpkgDesc :: PackageName -> IdreamDepInfo -> [ModuleName] -> PackageDesc
mkIpkgDesc pn (IdreamDepInfo _ mver _ ty msourcedir depends) modules =
  let isExe = ty /= PkgTypeLibrary
  in flip execState (minPackageDesc pn) $ do
    for_ mver (\pv -> modify (\pd -> pd { pdescVersion = Just pv }))
    for_ msourcedir (\s -> modify (\pd -> pd { pdescSourcedir = Just s }))
    when isExe (modify (\pd -> pd { pdescMain = Just (ModuleName ["Main"]), pdescExecutable = Just (toText pn) }))
    unless (isExe || null modules) (modify (\pd -> pd { pdescModules = modules }))
    unless (null depends) (modify (\pd -> pd { pdescDepends = fmap unrestrictedPD depends }))

mkIpkgContents :: PackageName -> IdreamDepInfo -> [ModuleName] -> Text
mkIpkgContents pn idi ms = "-- AUTOGENERATED BY idream. DO NOT EDIT.\n" <> toText (mkIpkgDesc pn idi ms)

idrisBuild :: Directory -> Codegen -> PackageName -> Directory -> FilePath -> [PackageName] -> AppM ()
idrisBuild projDir codegen pn path pkgFile tdepends = do
  absWorkDir <- fsMakeAbsolute (projDir </> workDir)
  let absBuildDir = absWorkDir </> buildDirName
      absOutputDir = absWorkDir </> outputDirName
      absInstallDir = absWorkDir </> installDirName
      depNames = fmap toString tdepends
      idpath = intercalate ":" (fmap (absInstallDir </>) depNames)
      idpathEnv = [("IDRIS2_PATH", idpath) | not (null idpath)]
      env = idpathEnv
      pkgDirPart = toString pn
      absPkgBuildDir = absBuildDir </> pkgDirPart
      absPkgOutputDir = absOutputDir </> pkgDirPart
      args = [ "--build", pkgFile
             , "--build-dir", absPkgBuildDir
             , "--output-dir", absPkgOutputDir
             , "--codegen", toString codegen
             , "--verbose"
             ]
      spec = Spec "idris2" args (Just (projDir </> path)) env
  procInvokeEnsure_ spec

installFiles :: Directory -> PackageName -> AppM ()
installFiles projDir pn = do
  logInfo ("Copying build files for " <> toText pn)
  let pkgDirPart = toString pn
      pkgBuildDir = projDir </> buildDir </> pkgDirPart
      pkgTtcDir = pkgBuildDir </> "ttc"
      projInstallDir = projDir </> installDir
      pkgInstallDir = projInstallDir </> pkgDirPart
  fsRemovePath pkgInstallDir
  ttcDirExists <- fsDoesDirectoryExist pkgTtcDir
  when ttcDirExists $ do
    fsCreateDir projInstallDir
    fsCopyDir pkgTtcDir pkgInstallDir
