module Idream.Command.Compile
  ( compileImpl
  ) where

import qualified Data.Set as Set
import qualified Data.Text as T
import Idream.Command.Common (PackageGroup, findExtRel, fullPkgDepsForGroup, getDepInfoMap, pkgGroupToText,
                              readDepInfoMap, readResolvedProject)
import Idream.Deps (closureDeps, linearizeDeps, lookupDeps)
import Idream.Effects.FileSystem (fsCopyDir, fsCreateDir, fsDoesDirectoryExist, fsMakeAbsolute, fsRemovePath,
                                  fsWriteFile)
import Idream.Effects.Process (Spec (..), procInvokeEnsure_)
import Idream.FileLogic (buildDir, buildDirName, installDir, installDirName, outputDirName, workDir)
import Idream.Prelude
import Idream.Types.Common (Codegen, PackageName, PackageType (..))
import Idream.Types.Internal (DepInfo (..), IdreamDepInfo (..), IpkgDepInfo (..), ResolvedProject (..))
import Idream.Types.Ipkg (ModuleName, extractModuleName)

compileImpl :: Directory -> PackageGroup -> AppM ()
compileImpl projDir group = do
  rp <- readResolvedProject projDir
  logInfo ("Compiling project " <> toText (rpName rp) <> " with " <> pkgGroupToText group)
  dim <- readDepInfoMap projDir rp
  let filtDeps = fullPkgDepsForGroup rp group dim
      linPkgs = linearizeDeps filtDeps
      transDeps = closureDeps filtDeps
  for_ linPkgs $ \pn -> do
    di <- getDepInfoMap pn dim
    let codegen = rpCodegen rp
        tdepends = Set.toList (lookupDeps pn transDeps)
    compilePkg projDir codegen di pn tdepends
  logInfo "Finished compiling"

compilePkg :: Directory -> Codegen -> DepInfo -> PackageName -> [PackageName] -> AppM ()
compilePkg projDir codegen di pn tdepends = do
  logInfo ("Compiling " <> toText pn)
  install <- case di of
    DepInfoBuiltin _ -> pure False
    DepInfoIdream idi -> do
      modules <- findIpkgModules projDir idi
      let path = idreamDepPath idi
          pkgFile = toString pn -<.> "ipkg"
          pkgContents = mkIpkgContents pn idi modules
          rootedPkgFile = projDir </> path </> pkgFile
      fsWriteFile rootedPkgFile pkgContents
      idrisBuild projDir codegen pn path pkgFile tdepends
      pure True
    DepInfoIpkg (IpkgDepInfo path pkgFile _) -> do
      idrisBuild projDir codegen pn path pkgFile tdepends
      pure True
  -- Copy TTC files to install
  when install (installFiles projDir pn)

findIpkgModules :: Directory -> IdreamDepInfo -> AppM [ModuleName]
findIpkgModules projDir (IdreamDepInfo _ path _ msourcedir _) = do
  let pkgPath = projDir </> path
      srcPath = maybe pkgPath (pkgPath </>) msourcedir
  idrFiles <- findExtRel "idr" srcPath
  pure (fmap extractModuleName idrFiles)

-- TODO(ejconlon) Split module and dep lists with newlines for better diffs
mkIpkgContents :: PackageName -> IdreamDepInfo -> [ModuleName] -> Text
mkIpkgContents pn (IdreamDepInfo _ _ ty msourcedir depends) modules =
  let isExe = ty /= PkgTypeLibrary
      modsList = T.intercalate ", " (fmap toText modules)
      depsList = T.intercalate ", " (fmap toText depends)
  in T.unlines $ filter (not . T.null)
    [ "-- AUTOGENERATED BY idream. DO NOT EDIT."
    , "package " <> toText pn
    , maybe "" (\s -> "sourcedir = \"" <> toText s <> "\"") msourcedir
    , if isExe then "main = Main" else ""
    , if isExe then "executable = \"" <> toText pn <> "\"" else ""
    , if null modules || isExe then "" else "modules = " <> modsList
    , if null depends then "" else "depends = " <> depsList
    ]

idrisBuild :: Directory -> Codegen -> PackageName -> Directory -> FilePath -> [PackageName] -> AppM ()
idrisBuild projDir codegen pn path pkgFile tdepends = do
  absWorkDir <- fsMakeAbsolute (projDir </> workDir)
  let absBuildDir = absWorkDir </> buildDirName
      absOutputDir = absWorkDir </> outputDirName
      absInstallDir = absWorkDir </> installDirName
      depNames = fmap toString tdepends
      idpath = intercalate ":" (fmap (absInstallDir </>) depNames)
      idpathEnv = [("IDRIS2_PATH", idpath) | not (null idpath)]
      env = idpathEnv
      pkgDirPart = toString pn
      absPkgBuildDir = absBuildDir </> pkgDirPart
      absPkgOutputDir = absOutputDir </> pkgDirPart
      args = [ "--build", pkgFile
             , "--build-dir", absPkgBuildDir
             , "--output-dir", absPkgOutputDir
             , "--codegen", toString codegen
             , "--verbose"
             ]
      spec = Spec "idris2" args (Just (projDir </> path)) env
  procInvokeEnsure_ spec

installFiles :: Directory -> PackageName -> AppM ()
installFiles projDir pn = do
  logInfo ("Copying build files for " <> toText pn)
  let pkgDirPart = toString pn
      pkgBuildDir = projDir </> buildDir </> pkgDirPart
      pkgTtcDir = pkgBuildDir </> "ttc"
      projInstallDir = projDir </> installDir
      pkgInstallDir = projInstallDir </> pkgDirPart
  fsRemovePath pkgInstallDir
  ttcDirExists <- fsDoesDirectoryExist pkgTtcDir
  when ttcDirExists $ do
    fsCreateDir projInstallDir
    fsCopyDir pkgTtcDir pkgInstallDir
